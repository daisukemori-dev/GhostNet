// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint32, externalEuint32} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

/// @title GhostNet encrypted group chat
/// @notice Manages Ghost groups with encrypted access keys and encrypted messages
contract GhostNet is ZamaEthereumConfig {
    struct Ghost {
        string name;
        address creator;
        euint32 encryptedKey;
        uint256 createdAt;
        uint256 memberCount;
    }

    struct GhostMessage {
        address sender;
        string ciphertext;
        uint256 timestamp;
    }

    uint256 public ghostCount;
    mapping(uint256 => Ghost) private ghosts;
    mapping(uint256 => mapping(address => bool)) private groupMembers;
    mapping(uint256 => address[]) private memberList;
    mapping(uint256 => GhostMessage[]) private groupMessages;

    event GhostCreated(uint256 indexed ghostId, address indexed creator, string name);
    event MemberJoined(uint256 indexed ghostId, address indexed account);
    event MessageSent(uint256 indexed ghostId, address indexed sender, uint256 messageIndex);

    error GhostNotFound(uint256 ghostId);
    error AlreadyMember(uint256 ghostId, address account);
    error NotMember(uint256 ghostId, address account);

    modifier ghostExists(uint256 ghostId) {
        if (ghostId == 0 || ghostId > ghostCount) {
            revert GhostNotFound(ghostId);
        }
        _;
    }

    /// @notice Create a new Ghost with an encrypted 6-8 digit key
    /// @param name The Ghost name
    /// @param encryptedKey External encrypted key generated by the creator
    /// @param inputProof Proof for the encrypted input
    /// @return ghostId Newly created Ghost identifier
    function createGhost(
        string calldata name,
        externalEuint32 encryptedKey,
        bytes calldata inputProof
    ) external returns (uint256 ghostId) {
        require(bytes(name).length > 0, "Name required");

        euint32 storedKey = FHE.fromExternal(encryptedKey, inputProof);
        FHE.allowThis(storedKey);
        FHE.allow(storedKey, msg.sender);

        ghostId = ++ghostCount;
        Ghost storage ghost = ghosts[ghostId];
        ghost.name = name;
        ghost.creator = msg.sender;
        ghost.encryptedKey = storedKey;
        ghost.createdAt = block.timestamp;
        ghost.memberCount = 1;

        groupMembers[ghostId][msg.sender] = true;
        memberList[ghostId].push(msg.sender);

        emit GhostCreated(ghostId, msg.sender, name);
        emit MemberJoined(ghostId, msg.sender);
    }

    /// @notice Join an existing Ghost and receive decrypt permission for its key
    /// @param ghostId The Ghost identifier
    function joinGhost(uint256 ghostId) external ghostExists(ghostId) {
        if (groupMembers[ghostId][msg.sender]) {
            revert AlreadyMember(ghostId, msg.sender);
        }

        groupMembers[ghostId][msg.sender] = true;
        ghosts[ghostId].memberCount += 1;
        memberList[ghostId].push(msg.sender);

        FHE.allow(ghosts[ghostId].encryptedKey, msg.sender);

        emit MemberJoined(ghostId, msg.sender);
    }

    /// @notice Post an encrypted message to a Ghost
    /// @param ghostId The Ghost identifier
    /// @param ciphertext The message encrypted client-side with the Ghost key
    function sendEncryptedMessage(uint256 ghostId, string calldata ciphertext) external ghostExists(ghostId) {
        if (!groupMembers[ghostId][msg.sender]) {
            revert NotMember(ghostId, msg.sender);
        }
        require(bytes(ciphertext).length > 0, "Ciphertext required");

        groupMessages[ghostId].push(
            GhostMessage({sender: msg.sender, ciphertext: ciphertext, timestamp: block.timestamp})
        );

        emit MessageSent(ghostId, msg.sender, groupMessages[ghostId].length - 1);
    }

    /// @notice Retrieve Ghost metadata and encrypted key
    function getGhost(
        uint256 ghostId
    )
        external
        view
        ghostExists(ghostId)
        returns (string memory name, address creator, euint32 encryptedKey, uint256 createdAt, uint256 memberCount)
    {
        Ghost storage ghost = ghosts[ghostId];
        return (ghost.name, ghost.creator, ghost.encryptedKey, ghost.createdAt, ghost.memberCount);
    }

    /// @notice Fetch the encrypted key for a Ghost
    function getGhostKey(uint256 ghostId) external view ghostExists(ghostId) returns (euint32) {
        return ghosts[ghostId].encryptedKey;
    }

    /// @notice List all Ghosts
    function getAllGhosts() external view returns (Ghost[] memory) {
        Ghost[] memory ghostList = new Ghost[](ghostCount);
        for (uint256 i = 0; i < ghostCount; i++) {
            uint256 ghostId = i + 1;
            ghostList[i] = ghosts[ghostId];
        }
        return ghostList;
    }

    /// @notice Check membership for a given account
    function isMember(uint256 ghostId, address account) external view ghostExists(ghostId) returns (bool) {
        return groupMembers[ghostId][account];
    }

    /// @notice Retrieve all members for a Ghost
    function getMembers(uint256 ghostId) external view ghostExists(ghostId) returns (address[] memory) {
        return memberList[ghostId];
    }

    /// @notice Count messages in a Ghost
    function getMessageCount(uint256 ghostId) external view ghostExists(ghostId) returns (uint256) {
        return groupMessages[ghostId].length;
    }

    /// @notice Get a slice of messages for pagination
    /// @param ghostId The Ghost identifier
    /// @param offset Starting message index
    /// @param limit Maximum number of messages to return
    function getMessages(
        uint256 ghostId,
        uint256 offset,
        uint256 limit
    ) external view ghostExists(ghostId) returns (GhostMessage[] memory) {
        uint256 totalMessages = groupMessages[ghostId].length;
        if (offset >= totalMessages) {
            return new GhostMessage[](0);
        }

        uint256 end = offset + limit;
        if (end > totalMessages) {
            end = totalMessages;
        }

        uint256 resultSize = end - offset;
        GhostMessage[] memory messageSlice = new GhostMessage[](resultSize);
        for (uint256 i = 0; i < resultSize; i++) {
            messageSlice[i] = groupMessages[ghostId][offset + i];
        }
        return messageSlice;
    }
}
